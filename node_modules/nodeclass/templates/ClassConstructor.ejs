var Constructor = function <%= className %>() {
    var tmp,
        implChildAbstracts,
        implAbstracts,
        constructorIsRunning,
        exposeProtected,
        Properties,
        Instance,
        key;

    if (this === undefined) {
        throw new Error("(nodeclass) Cannot create Class: You're trying to instantiate a class without the newoperator");
    }
    <% /* reads the flag-object. these flags are used to modify the constructor's behaviour. */ %>
    if(Constructor.$) {
        tmp = Constructor.$;
        Instance = tmp.Instance; <% /* provides the reference to the first child class that can be obtained via this.Instance */ %>
        implChildAbstracts = tmp.implChildAbstracts; <% /* an array that contains references to all abstract functions that are implemented in a child class */ %>
        exposeProtected = tmp.exposeProtected; <% /* if true, the constructor function exposes all protected class members */ %>
    }

    <%= abstractInstanceError %> <% /* if the class is abstract and the constructor is called by a non-child an error must be thrown */ %>

    if(!implChildAbstracts) {
        implChildAbstracts = {};
    }

    if (Instance === undefined) {
        Instance = this;
    }
    Properties = {};  <% /* creates the Properties-object, where all the class's properties are stored */ %>
    <%= properties %> <% /* gets replaced by various assignments for all properties: private, protected, public */ %>
    Properties.Instance = Instance;

    implAbstracts = implChildAbstracts;

    <% /* gets replaced by an object carrying all former abstract methods that are implemented by this class or a child class */ %>
    <% /* the next section is used to assign all abstract methods that are implemented by a child class to the current Properties-object. */ %>
    <% /* this is necessary so you can call this.abstractMethod in an abstract class. */ %>
    <%= implAbstracts %>
    for (key in implChildAbstracts) {
        if(implChildAbstracts.hasOwnProperty(key)) {
            Properties[key] = implChildAbstracts[key];
        }
    }

    <%= superConstructor %> <% /* gets replaced by the SuperConstructor-function, but only in case of the class has a super class. */ %>
    <%= initCall %> <% /* the init function is called now, if it is available */ %>
    <%= superConstructorCall %> <% /* now the super constructor is called in case of it hasnt been called by the init function of this class. */ %>

    <%= wrapper %> <% /* gets replaced by various assignments for all public properties */ %>
    if (exposeProtected) {
        <%= exposeWrapper %> <% /* gets replaced by various assignments for all protected properties */ %>
    }

    delete Constructor.$; <% /* deletes the flag-object */ %>
};
<% /* constructor definition ends here */ %>

<% /* this special function is used to call the constructor with an argument-array since you cant use the .apply()-method with the new operator. */ %>
Constructor.$construct = function (wrapper, args, implAbstracts) {
    function Instance() {
        return Constructor.apply(this, args);
    }
    Instance.prototype = Constructor.prototype;

    implAbstracts = implAbstracts || [];

    Constructor.$ = {
        exposeProtected: true,
        implChildAbstracts: implAbstracts,
        Instance: wrapper
    };

    return new Instance();
};